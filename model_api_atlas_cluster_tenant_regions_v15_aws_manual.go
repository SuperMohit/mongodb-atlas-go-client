/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ApiAtlasClusterTenantRegionsV15AWSManual Physical location from which MongoDB Cloud serves your MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Cloud creates them as part of the deployment. It assigns the VPC a Classless Inter-Domain Routing (CIDR) block.  To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts. GCP Clusters and Multi-region clusters require one VPC peering connection for each region. MongoDB nodes can use only the peering connection that resides in the same region as the nodes to communicate with the peered VPC.
type ApiAtlasClusterTenantRegionsV15AWSManual string

// List of ApiAtlasClusterTenantRegionsV15AWSManual
const (
	AF_SOUTH_1 ApiAtlasClusterTenantRegionsV15AWSManual = "AF_SOUTH_1"
	AP_EAST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_EAST_1"
	AP_NORTHEAST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_NORTHEAST_1"
	AP_NORTHEAST_2 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_NORTHEAST_2"
	AP_SOUTH_1 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_SOUTH_1"
	AP_SOUTHEAST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_SOUTHEAST_1"
	AP_SOUTHEAST_2 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_SOUTHEAST_2"
	AP_SOUTHEAST_3 ApiAtlasClusterTenantRegionsV15AWSManual = "AP_SOUTHEAST_3"
	EU_CENTRAL_1 ApiAtlasClusterTenantRegionsV15AWSManual = "EU_CENTRAL_1"
	EU_NORTH_1 ApiAtlasClusterTenantRegionsV15AWSManual = "EU_NORTH_1"
	EU_WEST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "EU_WEST_1"
	EU_WEST_3 ApiAtlasClusterTenantRegionsV15AWSManual = "EU_WEST_3"
	ME_SOUTH_1 ApiAtlasClusterTenantRegionsV15AWSManual = "ME_SOUTH_1"
	SA_EAST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "SA_EAST_1"
	US_EAST_1 ApiAtlasClusterTenantRegionsV15AWSManual = "US_EAST_1"
	US_WEST_2 ApiAtlasClusterTenantRegionsV15AWSManual = "US_WEST_2"
)

// All allowed values of ApiAtlasClusterTenantRegionsV15AWSManual enum
var AllowedApiAtlasClusterTenantRegionsV15AWSManualEnumValues = []ApiAtlasClusterTenantRegionsV15AWSManual{
	"AF_SOUTH_1",
	"AP_EAST_1",
	"AP_NORTHEAST_1",
	"AP_NORTHEAST_2",
	"AP_SOUTH_1",
	"AP_SOUTHEAST_1",
	"AP_SOUTHEAST_2",
	"AP_SOUTHEAST_3",
	"EU_CENTRAL_1",
	"EU_NORTH_1",
	"EU_WEST_1",
	"EU_WEST_3",
	"ME_SOUTH_1",
	"SA_EAST_1",
	"US_EAST_1",
	"US_WEST_2",
}

func (v *ApiAtlasClusterTenantRegionsV15AWSManual) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ApiAtlasClusterTenantRegionsV15AWSManual(value)
	for _, existing := range AllowedApiAtlasClusterTenantRegionsV15AWSManualEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ApiAtlasClusterTenantRegionsV15AWSManual", value)
}

// NewApiAtlasClusterTenantRegionsV15AWSManualFromValue returns a pointer to a valid ApiAtlasClusterTenantRegionsV15AWSManual
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewApiAtlasClusterTenantRegionsV15AWSManualFromValue(v string) (*ApiAtlasClusterTenantRegionsV15AWSManual, error) {
	ev := ApiAtlasClusterTenantRegionsV15AWSManual(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ApiAtlasClusterTenantRegionsV15AWSManual: valid values are %v", v, AllowedApiAtlasClusterTenantRegionsV15AWSManualEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ApiAtlasClusterTenantRegionsV15AWSManual) IsValid() bool {
	for _, existing := range AllowedApiAtlasClusterTenantRegionsV15AWSManualEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ApiAtlasClusterTenantRegionsV15AWSManual value
func (v ApiAtlasClusterTenantRegionsV15AWSManual) Ptr() *ApiAtlasClusterTenantRegionsV15AWSManual {
	return &v
}

type NullableApiAtlasClusterTenantRegionsV15AWSManual struct {
	value *ApiAtlasClusterTenantRegionsV15AWSManual
	isSet bool
}

func (v NullableApiAtlasClusterTenantRegionsV15AWSManual) Get() *ApiAtlasClusterTenantRegionsV15AWSManual {
	return v.value
}

func (v *NullableApiAtlasClusterTenantRegionsV15AWSManual) Set(val *ApiAtlasClusterTenantRegionsV15AWSManual) {
	v.value = val
	v.isSet = true
}

func (v NullableApiAtlasClusterTenantRegionsV15AWSManual) IsSet() bool {
	return v.isSet
}

func (v *NullableApiAtlasClusterTenantRegionsV15AWSManual) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableApiAtlasClusterTenantRegionsV15AWSManual(val *ApiAtlasClusterTenantRegionsV15AWSManual) *NullableApiAtlasClusterTenantRegionsV15AWSManual {
	return &NullableApiAtlasClusterTenantRegionsV15AWSManual{value: val, isSet: true}
}

func (v NullableApiAtlasClusterTenantRegionsV15AWSManual) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableApiAtlasClusterTenantRegionsV15AWSManual) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

