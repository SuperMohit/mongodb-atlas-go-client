/*
MongoDB Atlas Administration API

The MongoDB Atlas Administration API allows developers to manage all components in MongoDB Atlas. To learn more, review the [Administration API overview](https://www.mongodb.com/docs/atlas/api/atlas-admin-api/). This OpenAPI specification covers all of the collections with the exception of Alerts, Alert Configurations, and Events. Refer to the [legacy documentation](https://www.mongodb.com/docs/atlas/reference/api-resources/) for the specifications of these resources.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ServerlessPrivateEndpointsApiService ServerlessPrivateEndpointsApi service
type ServerlessPrivateEndpointsApiService service

type ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService *ServerlessPrivateEndpointsApiService
	groupId string
	instanceName string
	envelope *bool
	apiAtlasServerlessTenantEndpointCreateView *ApiAtlasServerlessTenantEndpointCreateView
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) ApiAtlasServerlessTenantEndpointCreateView(apiAtlasServerlessTenantEndpointCreateView ApiAtlasServerlessTenantEndpointCreateView) ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.apiAtlasServerlessTenantEndpointCreateView = &apiAtlasServerlessTenantEndpointCreateView
	return r
}

func (r ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	return r.ApiService.CreateOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
CreateOnePrivateEndpointForOneServerlessInstance Create One Private Endpoint for One Serverless Instance

Creates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 A new endpoint won't be immediately available after creation.  Read the steps in the linked tutorial for detailed guidance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance for which the tenant endpoint will be created.
 @return ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) CreateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest {
	return ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
	}
}

// Execute executes the request
//  @return CreateOnePrivateEndpointForOneServerlessInstance201Response
func (a *ServerlessPrivateEndpointsApiService) CreateOnePrivateEndpointForOneServerlessInstanceExecute(r ApiCreateOnePrivateEndpointForOneServerlessInstanceRequest) (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOnePrivateEndpointForOneServerlessInstance201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.CreateOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v1.0/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAtlasServerlessTenantEndpointCreateView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService *ServerlessPrivateEndpointsApiService
	groupId string
	instanceName string
	endpointId string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) Envelope(envelope bool) ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveOnePrivateEndpointFromOneServerlessInstanceExecute(r)
}

/*
RemoveOnePrivateEndpointFromOneServerlessInstance Remove One Private Endpoint for One Serverless Instance

Remove one private endpoint from one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance from which the tenant endpoint will be removed.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be removed.
 @return ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) RemoveOnePrivateEndpointFromOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest {
	return ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *ServerlessPrivateEndpointsApiService) RemoveOnePrivateEndpointFromOneServerlessInstanceExecute(r ApiRemoveOnePrivateEndpointFromOneServerlessInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.RemoveOnePrivateEndpointFromOneServerlessInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v1.0/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService *ServerlessPrivateEndpointsApiService
	groupId string
	instanceName string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) Envelope(envelope bool) ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) Execute() ([]ReturnAllPrivateEndpointsForOneServerlessInstance200ResponseInner, *http.Response, error) {
	return r.ApiService.ReturnAllPrivateEndpointsForOneServerlessInstanceExecute(r)
}

/*
ReturnAllPrivateEndpointsForOneServerlessInstance Return All Private Endpoints for One Serverless Instance

Returns all private endpoints for one serverless instance. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
 @return ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) ReturnAllPrivateEndpointsForOneServerlessInstance(ctx context.Context, groupId string, instanceName string) ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest {
	return ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
	}
}

// Execute executes the request
//  @return []ReturnAllPrivateEndpointsForOneServerlessInstance200ResponseInner
func (a *ServerlessPrivateEndpointsApiService) ReturnAllPrivateEndpointsForOneServerlessInstanceExecute(r ApiReturnAllPrivateEndpointsForOneServerlessInstanceRequest) ([]ReturnAllPrivateEndpointsForOneServerlessInstance200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReturnAllPrivateEndpointsForOneServerlessInstance200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.ReturnAllPrivateEndpointsForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v1.0/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService *ServerlessPrivateEndpointsApiService
	groupId string
	instanceName string
	endpointId string
	envelope *bool
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	return r.ApiService.ReturnOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
ReturnOnePrivateEndpointForOneServerlessInstance Return One Private Endpoint for One Serverless Instance

Return one private endpoint for one serverless instance. Identify this endpoint using its unique ID. You must have at least the Project Read Only role for the project to successfully call this resource. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint.
 @return ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) ReturnOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest {
	return ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return CreateOnePrivateEndpointForOneServerlessInstance201Response
func (a *ServerlessPrivateEndpointsApiService) ReturnOnePrivateEndpointForOneServerlessInstanceExecute(r ApiReturnOnePrivateEndpointForOneServerlessInstanceRequest) (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOnePrivateEndpointForOneServerlessInstance201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.ReturnOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v1.0/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return localVarReturnValue, nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return localVarReturnValue, nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest struct {
	ctx context.Context
	ApiService *ServerlessPrivateEndpointsApiService
	groupId string
	instanceName string
	endpointId string
	envelope *bool
	apiAtlasServerlessTenantEndpointUpdateView *ApiAtlasServerlessTenantEndpointUpdateView
}

// Flag that indicates whether Application wraps the response in an &#x60;envelope&#x60; JSON object. Some API clients cannot access the HTTP response headers or status code. To remediate this, set envelope&#x3D;true in the query. Endpoints that return a list of results use the results object as an envelope. Application adds the status parameter to the response body.
func (r ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) Envelope(envelope bool) ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.envelope = &envelope
	return r
}

func (r ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) ApiAtlasServerlessTenantEndpointUpdateView(apiAtlasServerlessTenantEndpointUpdateView ApiAtlasServerlessTenantEndpointUpdateView) ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	r.apiAtlasServerlessTenantEndpointUpdateView = &apiAtlasServerlessTenantEndpointUpdateView
	return r
}

func (r ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) Execute() (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	return r.ApiService.UpdateOnePrivateEndpointForOneServerlessInstanceExecute(r)
}

/*
UpdateOnePrivateEndpointForOneServerlessInstance Update One Private Endpoint for One Serverless Instance

Updates one private endpoint for one serverless instance. To use this resource, the requesting API Key must have the Project Owner role. This resource doesn't require the API Key to have an Access List.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Unique 24-hexadecimal digit string that identifies your project.
 @param instanceName Human-readable label that identifies the serverless instance associated with the tenant endpoint that will be updated.
 @param endpointId Unique 24-hexadecimal digit string that identifies the tenant endpoint which will be updated.
 @return ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest
*/
func (a *ServerlessPrivateEndpointsApiService) UpdateOnePrivateEndpointForOneServerlessInstance(ctx context.Context, groupId string, instanceName string, endpointId string) ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest {
	return ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		instanceName: instanceName,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return CreateOnePrivateEndpointForOneServerlessInstance201Response
func (a *ServerlessPrivateEndpointsApiService) UpdateOnePrivateEndpointForOneServerlessInstanceExecute(r ApiUpdateOnePrivateEndpointForOneServerlessInstanceRequest) (*CreateOnePrivateEndpointForOneServerlessInstance201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOnePrivateEndpointForOneServerlessInstance201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessPrivateEndpointsApiService.UpdateOnePrivateEndpointForOneServerlessInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/atlas/v1.0/groups/{groupId}/privateEndpoint/serverless/instance/{instanceName}/endpoint/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupId) < 24 {
		return localVarReturnValue, nil, reportError("groupId must have at least 24 elements")
	}
	if strlen(r.groupId) > 24 {
		return localVarReturnValue, nil, reportError("groupId must have less than 24 elements")
	}
	if strlen(r.instanceName) > 64 {
		return localVarReturnValue, nil, reportError("instanceName must have less than 64 elements")
	}
	if strlen(r.endpointId) < 24 {
		return localVarReturnValue, nil, reportError("endpointId must have at least 24 elements")
	}
	if strlen(r.endpointId) > 24 {
		return localVarReturnValue, nil, reportError("endpointId must have less than 24 elements")
	}

	if r.envelope != nil {
		localVarQueryParams.Add("envelope", parameterToString(*r.envelope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiAtlasServerlessTenantEndpointUpdateView
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
